<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <title>WebXR Billar Passthrough (Paso 56 - Física Bolas + Disparo)</title> <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; background-color: #000; }
        canvas { display: block; }
        #ar-button { /* Style for the AR button */
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 999;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- Global Variables ---
        let camera, scene, renderer;
        let tableGroup; // Contenedor

        // Física Completa (Excepto cuerpos de bandas)
        let world;
        const timeStep = 1 / 60;
        const tableParts = []; // Para superficie (y bandas si se añadieran)
        const balls = []; // Array para { mesh, body, name }
        let cueBall;
        let initialBallPositions = {};
        let ballMaterial, cushionMaterial, tableMaterial; // Todos los materiales
        let cm_ball_ball, cm_ball_cushion, cm_ball_table; // Contact materials

        // WebXR Controller Variables
        let controller1, controller2;
        let cueController = null; // Se asignará al controller2
        let cueStickMesh; // Visual del taco
        let isTriggerDown = false;

        // Gameplay State
        let score = 0;
        let isStrokeInProgress = false;
        let hitYellowAfterStrokeStart = false;
        let hitRedAfterStrokeStart = false;
        let cushionHitsThisStroke = 0;
        const stopVelocityThreshold = 0.01;

        // Constants
        const ballRadius = 0.03075;
        const ballMass = 0.21; // Masa para bolas dinámicas
        const tableWidth = 1.42;
        const tableHeight = 2.84;
        const tableThickness = 0.01;
        const cushionHeight = 0.05;
        const cushionWidth = 0.05;
        const tableSurfaceY = -0.4;

        init();

        // --- Initialization ---
        function init() {
            console.log("Iniciando escena WebXR Billar (Paso 56)...");

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, tableSurfaceY + 1.5, 1);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearAlpha(0);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true; // Mantener sombras
            document.body.appendChild(renderer.domElement);

            const arButton = ARButton.createButton(renderer);
            document.body.appendChild(arButton);

            // Iluminación
            scene.add(new THREE.AmbientLight(0xAAAAAA));
            const spotLight = new THREE.SpotLight(0xffffff, 0.9, 0, Math.PI / 4, 1);
            spotLight.position.set(0, tableSurfaceY + 2, -1.5);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);
            scene.add(camera);

            // --- Physics World (Cannon.js) ---
            if (typeof CANNON === 'undefined') { console.error("Cannon.js no cargado!"); return; }
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Gravedad necesaria para las bolas
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true; // Permitir dormir
            world.solver.iterations = 15;
            console.log("Mundo físico Cannon.js creado.");

            // Physics Materials Setup
            ballMaterial = new CANNON.Material('ball'); // Material para bolas
            cushionMaterial = new CANNON.Material('cushion');
            tableMaterial = new CANNON.Material('table');
            console.log("Materiales físicos creados.");

            // Contact Materials - Necesarios ahora que habrá bolas
            cm_ball_ball = new CANNON.ContactMaterial(ballMaterial, ballMaterial, { friction: 0.1, restitution: 0.9 });
            cm_ball_cushion = new CANNON.ContactMaterial(ballMaterial, cushionMaterial, { friction: 0.15, restitution: 0.7 }); // Aunque no haya cuerpos de cojín, definimos
            cm_ball_table = new CANNON.ContactMaterial(ballMaterial, tableMaterial, { friction: 0.04, restitution: 0.2 });
            world.addContactMaterial(cm_ball_ball);
            world.addContactMaterial(cm_ball_cushion); // Añadir aunque no haya cuerpos aún
            world.addContactMaterial(cm_ball_table);
            console.log("Materiales de contacto añadidos al mundo.");


            // --- Crear Grupo de la Mesa ---
            tableGroup = new THREE.Group();
            tableGroup.position.set(0, tableSurfaceY, -1.5); // Posicionar el grupo
            scene.add(tableGroup);
            console.log("Table group creado en Y:", tableSurfaceY);

            // --- Crear Superficie (Visual + Física AÑADIDA) ---
            createTableSurface(); // Añade tableBody a world

            // --- Crear Cojines y Marco (SOLO VISUAL) ---
            createCushionsAndFrameVisualsOnly(tableGroup); // Solo visual por ahora

            // --- Crear LAS TRES BOLAS (Visual + Física AÑADIDA) ---
            createBalls(); // Llama a la función completa que añade bodies

            // --- Configurar Mandos (Visual) ---
            setupControllers(); // Taco posicionado

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);

            // --- Start Animation Loop ---
            renderer.setAnimationLoop(animate); // animate ahora con física
            console.log("Inicialización con física de bolas completa (Paso 56).");
        }

        // --- Función para crear superficie (Visual + Física AÑADIDA a World) ---
        function createTableSurface() {
             // console.log("Creando superficie (Visual + Física)...");
             let tableSurfaceMesh;
             try {
                 const tableGeometry = new THREE.BoxGeometry(tableWidth, tableThickness, tableHeight);
                 const tableMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.9 });
                 tableSurfaceMesh = new THREE.Mesh(tableGeometry, tableMeshMaterial);
                 tableSurfaceMesh.name = "TableSurface";
                 tableSurfaceMesh.position.y = -tableThickness / 2; // Local
                 tableSurfaceMesh.receiveShadow = true;
                 tableGroup.add(tableSurfaceMesh);
             } catch(e) { console.error("***** ERROR creando malla de tapete:", e); return; }

             let tableBody;
             try {
                 const tableShape = new CANNON.Box(new CANNON.Vec3(tableWidth / 2, tableThickness / 2, tableHeight / 2));
                 tableBody = new CANNON.Body({ mass: 0, material: tableMaterial });
                 tableBody.addShape(tableShape);
                 const tableBodyWorldPos = tableGroup.localToWorld(tableSurfaceMesh.position.clone());
                 tableBody.position.copy(tableBodyWorldPos);
                 tableBody.quaternion.copy(tableGroup.quaternion);
                 world.addBody(tableBody); // Añadir a world
                 tableParts.push({ mesh: tableSurfaceMesh, body: tableBody, type: 'table' });
             } catch(e) { console.error("***** ERROR creando/añadiendo cuerpo físico de superficie:", e); }
             // console.log("Función createTableSurface completada.");
         }


        // --- Función para crear cojines y marco (SOLO VISUAL) ---
        function createCushionsAndFrameVisualsOnly(group) {
            console.log("Creando visuales de cojines y marco (SIN FÍSICA)..."); // Log actualizado
            const cushionYPos = cushionHeight / 2;
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const cushionGeometryLong = new THREE.BoxGeometry(tableWidth + 2 * cushionWidth, cushionHeight, cushionWidth);
            const cushionGeometryShort = new THREE.BoxGeometry(cushionWidth, cushionHeight, tableHeight);
            const cushionPositions = [
                 { x: 0, y: cushionYPos, z: tableHeight / 2 + cushionWidth / 2, geometry: cushionGeometryLong },
                 { x: 0, y: cushionYPos, z: -tableHeight / 2 - cushionWidth / 2, geometry: cushionGeometryLong },
                 { x: tableWidth / 2 + cushionWidth / 2, y: cushionYPos, z: 0, geometry: cushionGeometryShort },
                 { x: -tableWidth / 2 - cushionWidth / 2, y: cushionYPos, z: 0, geometry: cushionGeometryShort }
            ];

            cushionPositions.forEach((posData, index) => {
                 try {
                     const cushionMesh = new THREE.Mesh(posData.geometry, woodMaterial);
                     cushionMesh.position.set(posData.x, posData.y, posData.z); // Local
                     cushionMesh.castShadow = true;
                     cushionMesh.receiveShadow = true;
                     group.add(cushionMesh);
                     // NO crear ni añadir cuerpo físico aquí
                 } catch(e) { console.error(`***** ERROR creando/añadiendo cojín visual ${index+1}:`, e); }
            });
            try {
                 const baseHeight = 0.15;
                 const baseGeometry = new THREE.BoxGeometry(tableWidth + 2 * cushionWidth + 0.1, baseHeight, tableHeight + 2 * cushionWidth + 0.1);
                 const baseMesh = new THREE.Mesh(baseGeometry, woodMaterial);
                 baseMesh.position.y = -tableThickness - baseHeight / 2; // Local
                 baseMesh.castShadow = true;
                 baseMesh.receiveShadow = true;
                 group.add(baseMesh);
            } catch(e) { console.error("***** ERROR creando/añadiendo base visual:", e); }
            // console.log("Función createCushionsAndFrameVisualsOnly completada.");
        }


        // --- Create Balls Function (Visual + Physics Body Creation/Adding) ---
        function createBalls() {
             const sphereGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
             const damping = 0.15;
             const ballYPos = ballRadius; // Posición Y local sobre la superficie
             const ballData = [
                 { name: 'white', color: 0xffffff, x: 0, z: tableHeight * 0.25 },
                 { name: 'yellow', color: 0xffff00, x: tableWidth * 0.2, z: -tableHeight * 0.25 },
                 { name: 'red', color: 0xff0000, x: -tableWidth * 0.2, z: -tableHeight * 0.25 }
             ];
             balls.length = 0; // Limpiar array
             initialBallPositions = {}; // Limpiar posiciones

             console.log("Creando bolas (Visual + Física)...");
             ballData.forEach(data => {
                 // Visual Mesh
                 const material = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.1, metalness: 0.1 });
                 const mesh = new THREE.Mesh(sphereGeometry, material);
                 mesh.position.set(data.x, ballYPos, data.z); // Posición LOCAL
                 mesh.castShadow = true; // Bolas proyectan sombras
                 tableGroup.add(mesh); // Añadir al grupo

                 // Physics Body
                 let body = null;
                 try {
                     const shape = new CANNON.Sphere(ballRadius);
                     body = new CANNON.Body({
                         mass: ballMass, // Masa > 0 para ser dinámico
                         material: ballMaterial,
                         shape: shape,
                         linearDamping: damping,
                         angularDamping: damping,
                         allowSleep: true,
                         sleepSpeedLimit: 0.1,
                         sleepTimeLimit: 1.0
                     });
                     const worldPos = tableGroup.localToWorld(mesh.position.clone()); // Calcular pos MUNDIAL inicial
                     body.position.copy(worldPos);
                     body.addEventListener('collide', onCollision); // Añadir listener de colisión
                     // ***** AÑADIR BOLAS A WORLD *****
                     world.addBody(body); // Añadir cuerpo al mundo físico
                     // console.log(` > Cuerpo físico de ${data.name} añadido al mundo.`);

                 } catch (e) { console.error(`Error creando/añadiendo cuerpo físico para ${data.name}:`, e); }

                 // Guardar referencia
                 const ballInfo = { mesh: mesh, body: body, name: data.name };
                 balls.push(ballInfo);
                 if (data.name === 'white') { cueBall = ballInfo; }
                 initialBallPositions[data.name] = { mesh: mesh.position.clone(), body: body ? body.position.clone() : null };

             });
             console.log("Creación de bolas (visual + cuerpo físico) completa.");
        }


        // --- Setup Controllers (Con taco posicionado correctamente) ---
        function setupControllers() { /* ... (definición completa como antes) ... */ }


        // --- WebXR Event Handlers (Disparo Activado) ---
        function onSelectStart(event) {
             const controller = event.target;
             if (controller === cueController) { isTriggerDown = true; }
        }
        function onSelectEnd(event) {
             const controller = event.target;
             if (controller === cueController && isTriggerDown) {
                 isTriggerDown = false;
                 console.log(">>> Trigger Released - Intentando disparar...");
                 shootBall(); // Llamar a la función de disparo
             }
        }

        // --- Billiards Logic Functions ---

        // shootBall Function - CON COMPROBACIÓN isQuiet MODIFICADA
        function shootBall() {
            console.log("--- Entrando a shootBall() ---");
            if (!cueBall || !cueBall.body) { console.error("Error: cueBall o cueBall.body no definido."); return; }
            if (!cueController) { console.error("Error: cueController no definido en shootBall."); return; }
            console.log("Estado actual: isStrokeInProgress =", isStrokeInProgress);

            // Comprobación de quietud MÁS PERMISIVA
            let allQuiet = true;
            const quietCheckThreshold = 0.3;
            // console.log(`Comprobando si las bolas están quietas (Umbral Vel^2 < ${quietCheckThreshold} O Sleeping):`);
            balls.forEach((b, index) => {
                if (!b || !b.body) { console.warn(`Advertencia: Falta body para bola ${index} en chequeo isQuiet.`); return; }
                const sleep = b.body.sleepState === CANNON.Body.SLEEPING;
                if (sleep) { return; }
                const vel = b.body.velocity.lengthSquared();
                if (vel > quietCheckThreshold) { allQuiet = false; }
            });
            console.log("Resultado de isQuiet (Umbral Relajado):", allQuiet);

            if (!allQuiet || isStrokeInProgress) {
                console.log("CONDICIÓN DE DISPARO NO CUMPLIDA:", !allQuiet ? "Bolas en movimiento." : "", isStrokeInProgress ? "Tiro ya en progreso." : "");
                return;
            }

            // 1. Obtener dirección del taco (mando)
            const aimDirection = new THREE.Vector3();
            try {
                 cueController.getWorldDirection(aimDirection);
                 aimDirection.y = 0;
                 aimDirection.normalize();
            } catch (e) { console.error("Error obteniendo dirección del mando:", e); return; }

            // 2. Magnitud de Impulso (fija por ahora)
            const impulseMagnitude = 0.8;
            // 3. Punto de Golpeo (centro por ahora)
            const hitOffset = new CANNON.Vec3(0, 0, 0);
            // 4. Aplicar Impulso
            const impulse = new CANNON.Vec3( aimDirection.x * impulseMagnitude, 0, aimDirection.z * impulseMagnitude );
            console.log("Aplicando impulso:", impulse);
            try {
                cueBall.body.wakeUp();
                cueBall.body.applyImpulse(impulse, hitOffset);
                console.log("Impulso aplicado a cueBall.body.");
            } catch(e) { console.error("¡Error al aplicar impulso!", e); return; }

            // 5. Iniciar seguimiento del tiro
            isStrokeInProgress = true;
            hitYellowAfterStrokeStart = false;
            hitRedAfterStrokeStart = false;
            cushionHitsThisStroke = 0;
            console.log(`¡Disparo Realizado! Fuerza: ${impulseMagnitude.toFixed(2)}. Stroke iniciado.`);
            console.log("--- Saliendo de shootBall() ---");
        }

        // onCollision Function - Necesaria para lógica de puntuación
        function onCollision(event) {
             if (!isStrokeInProgress) return;
             const bodyA = event.contact.bi;
             const bodyB = event.contact.bj;
             const whiteBallBody = cueBall?.body;
             const yellowBallBody = balls.find(b => b.name === 'yellow')?.body;
             const redBallBody = balls.find(b => b.name === 'red')?.body;
             if (!whiteBallBody || !yellowBallBody || !redBallBody) return;
             // Lógica simple para detectar primer golpe a amarilla y roja + golpes a banda
             // NOTA: Aún no hay cuerpos físicos para las bandas (cushionMaterial)
             /* if ((bodyA === whiteBallBody && bodyB.material === cushionMaterial) || (bodyB === whiteBallBody && bodyA.material === cushionMaterial)) {
                 cushionHitsThisStroke++;
                 console.log("Golpe a banda! Total:", cushionHitsThisStroke); // Log temporal
             } else */
             if (!hitYellowAfterStrokeStart && ((bodyA === whiteBallBody && bodyB === yellowBallBody) || (bodyA === yellowBallBody && bodyB === whiteBallBody))) {
                 hitYellowAfterStrokeStart = true;
                 console.log("Blanca golpea AMARILLA"); // Log temporal
             } else if (!hitRedAfterStrokeStart && ((bodyA === whiteBallBody && bodyB === redBallBody) || (bodyA === redBallBody && bodyB === whiteBallBody))) {
                 hitRedAfterStrokeStart = true;
                 console.log("Blanca golpea ROJA"); // Log temporal
             }
        }
        // resetBall Function - Necesaria si bolas se caen (aunque no debería pasar sin agujeros)
        function resetBall(ball) {
             if (!ball || !ball.body || !ball.mesh || !initialBallPositions[ball.name]) { return; }
             // console.log(`--- RESETEANDO BOLA ${ball.name.toUpperCase()} ---`);
             ball.body.velocity.set(0, 0, 0);
             ball.body.angularVelocity.set(0, 0, 0);
             ball.body.sleep();
             ball.body.position.copy(initialBallPositions[ball.name].body); // Reset body a pos MUNDIAL inicial
             ball.body.wakeUp();
             ball.mesh.position.copy(initialBallPositions[ball.name].mesh); // Reset mesh a pos LOCAL inicial
             ball.mesh.quaternion.set(0, 0, 0, 1);
             if (ball.name === 'white') { isStrokeInProgress = false; } // Resetear estado del tiro si es la blanca
        }
        // checkBallsFallen Function - Necesaria
        function checkBallsFallen() {
             let needsReset = false;
             const fallThreshold = tableSurfaceY - ballRadius * 5; // Umbral bastante bajo
             balls.forEach(ball => {
                 // Añadir chequeo extra por si body es null
                 if (ball && ball.body && ball.body.position.y < fallThreshold) {
                     console.log(`¡Bola ${ball.name.toUpperCase()} se cayó! Reseteando.`);
                     resetBall(ball);
                     needsReset = true;
                 }
             });
             if (needsReset) { isStrokeInProgress = false; }
        }
         // checkStrokeEnd Function - Necesaria
         function checkStrokeEnd() {
             if (!isStrokeInProgress) return;
             // Comprobar si TODAS las bolas están dormidas o casi paradas
             const allStopped = balls.every(b => {
                 // Añadir chequeo extra por si body es null
                 if (!b || !b.body) return true; // Considerar quieta si falta body
                 return b.body.sleepState === CANNON.Body.SLEEPING || b.body.velocity.lengthSquared() < stopVelocityThreshold
             });
             if (allStopped) {
                 console.log("Tiro finalizado. Comprobando resultado...");
                 // Comprobar si se hizo carambola (SIN BANDAS AÚN)
                 if (hitYellowAfterStrokeStart && hitRedAfterStrokeStart /*&& cushionHitsThisStroke >= 3*/) {
                     score++;
                     // console.log(`¡CARAMBOLA! Puntuación: ${score}`); // Log simplificado
                     console.log(`¡CARAMBOLA (sin bandas)! Puntuación: ${score}`);
                 } else { /*console.log("Tiro fallido o carambola no válida.");*/ }

                 // Resetear estado para el próximo tiro
                 isStrokeInProgress = false;
                 hitYellowAfterStrokeStart = false;
                 hitRedAfterStrokeStart = false;
                 cushionHitsThisStroke = 0; // Resetear aunque no se usen
                 // console.log("Listo para el siguiente tiro.");
             }
         }


        // --- Window Resize Handler ---
        function onWindowResize() { /* ... */ }

        // --- Animation Loop ---
        function animate() {
            // ***** REINTRODUCIDO: Actualizar física *****
            if (world) {
                try { world.step(timeStep); } catch (e) { console.error("Error during world.step():", e); }
            }

            // ***** REINTRODUCIDO: Sincronizar visuales con física *****
            balls.forEach(ball => {
                if (ball && ball.body && ball.mesh && tableGroup) {
                    try {
                        const bodyPos = ball.body.position;
                        if (isNaN(bodyPos.x) || isNaN(bodyPos.y) || isNaN(bodyPos.z)) {
                             console.warn(`Posición inválida (NaN) detectada para ${ball.name} body ANTES de worldToLocal.`);
                             return;
                        }
                        const localPos = tableGroup.worldToLocal(bodyPos.clone());
                        ball.mesh.position.copy(localPos);
                        ball.mesh.quaternion.copy(ball.body.quaternion);
                    } catch(e) { console.error(`Error syncing ball ${ball.name}:`, e); }
                }
            });

            // ***** REINTRODUCIDO: Comprobar estado del juego *****
            try { checkBallsFallen(); checkStrokeEnd(); } catch (e) { console.error("Error during game state checks:", e); }

            // Render Scene
            try { renderer.render(scene, camera); } catch (e) { console.error("Error during renderer.render():", e); }
        }

        // --- Copiar aquí las definiciones completas de las funciones auxiliares ---
        // (createTableSurface, createCushionsAndFrameVisualsOnly, createBalls, setupControllers,
        //  onSelectStart, onSelectEnd, onCollision, resetBall, checkBallsFallen,
        //  checkStrokeEnd, onWindowResize, shootBall, animate)
        // Asegúrate de que las definiciones completas de las funciones estén presentes.


    </script>
</body>
</html>






