<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR - Cargar FBX con ARButton</title> <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #ar-button { /* Estilo para el botón de ARButton */
            position: absolute;
            bottom: 20px;
            right: 20px; /* Lo ponemos a la derecha como en tu ejemplo */
            padding: 12px 20px;
            border-radius: 4px;
            background-color: rgba(0, 128, 255, 0.8);
            color: white;
            font-weight: bold;
            border: none;
            cursor: pointer;
            z-index: 999;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
                "fflate": "https://unpkg.com/fflate@0.8.1/esm/index.js" /* Añadido para FBXLoader */
            }
        }
    </script>

    <script type="module">
        // Importaciones Principales
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        // Importaciones para Carga y Debug
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { BoxHelper } from 'three'; // BoxHelper ahora es parte del core
        import * as fflate from 'fflate'; // Importar fflate (necesario para FBXLoader internamente)

        // Variables globales
        let camera, scene, renderer;
        let controller1, controller2; // Mandos
        let raycaster;
        let tempMatrix = new THREE.Matrix4(); // Matriz temporal para cálculos
        let grabbingController = null; // Qué mando está agarrando
        let grabbedObject = null; // Qué objeto está agarrado (será loadedModel)
        let loadedModel = null; // Referencia al modelo FBX cargado
        let modelBoxHelper = null; // Ayudante visual

        // --- Inicialización ---
        init();

        function init() {
            console.log("Iniciando escena...");
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Ajustamos Z para que no esté demasiado cerca al inicio si el modelo es grande
            camera.position.set(0, 1.6, 1.5); // Un poco más atrás que en tu ejemplo del cubo

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // renderer.setClearAlpha(0); // No necesario con alpha: true en el renderer
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Crear y añadir botón ARButton (maneja inicio/fin de sesión)
            // ARButton requiere que la sesión sea 'immersive-ar' y opcionalmente 'local-floor'
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['local-floor'] // Pedir anclaje al suelo si es posible
            });
            arButton.id = 'ar-button'; // Asignar ID para estilo si es necesario
            document.body.appendChild(arButton);
            console.log("ARButton añadido.");

            // --- Cargar Modelo FBX (en lugar de crear cubo) ---
            loadFBXModel();

            // --- Añadir Luces ---
            // Ajustar intensidad si es necesario
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Intensidad ajustada
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Intensidad ajustada
            directionalLight.position.set(1, 2, 1).normalize(); // Posición ajustada
            scene.add(directionalLight);

            // --- Configuración de Mandos ---
            setupControllers();

            // --- Configuración de Raycaster ---
            raycaster = new THREE.Raycaster();

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate); // Iniciar bucle de animación/renderizado
            console.log("Inicialización completa, iniciando bucle de animación.");
        }

        // --- Cargar Modelo FBX ---
        function loadFBXModel() {
            // FBXLoader ahora se importa directamente
            const loader = new FBXLoader();
            // Asegúrate que fflate está disponible (aunque FBXLoader lo usa internamente)
            // FBXLoader puede necesitar setPath si las texturas no están junto al FBX
            // loader.setPath('./path/to/textures/'); // Opcional

            const modelUrl = 'planta_interior_2.fbx'; // Nombre del archivo FBX

            console.log(`Intentando cargar modelo FBX desde: ${modelUrl}`);

            loader.load(
                modelUrl,
                // onLoad
                function (object) {
                    console.log("Modelo FBX cargado correctamente:", object);
                    loadedModel = object;

                    // Aplicar escala y posición encontradas anteriormente
                    loadedModel.scale.set(0.001, 0.001, 0.001);
                    loadedModel.position.set(0, 1.0, -1.5); // Y=1m (aprox altura media), Z=-1.5m (delante)

                    // Asegurar sombras (si los materiales las soportan)
                     loadedModel.traverse(function (child) {
                         if (child.isMesh) {
                             child.castShadow = true;
                             child.receiveShadow = true;
                         }
                     });

                    scene.add(loadedModel);
                    console.log("Modelo FBX añadido a la escena.");

                    // Añadir BoxHelper para depuración
                    if (modelBoxHelper) scene.remove(modelBoxHelper); // Limpiar el viejo
                    modelBoxHelper = new BoxHelper( loadedModel, 0xffff00 ); // Amarillo
                    scene.add( modelBoxHelper );
                    console.log("BoxHelper añadido/actualizado para el modelo.");

                    // Podríamos mostrar un mensaje temporal de éxito aquí si quisiéramos
                },
                // onProgress (opcional)
                function (xhr) {
                    const percentLoaded = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Modelo FBX ${percentLoaded}% cargado`);
                },
                // onError
                function (error) {
                    console.error("Error al cargar el modelo FBX:", error);
                    // Aquí podríamos usar la función showMessage si la reintroducimos
                    alert(`Error al cargar modelo FBX: ${error.message || 'Ver consola'}`);
                }
            );
        }

         // --- Configuración de Mandos ---
         function setupControllers() {
            // Mando Izquierdo (index 0)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            console.log("Mando 1 (Izq) añadido y listeners configurados.");

            // Mando Derecho (index 1)
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);
            console.log("Mando 2 (Der) añadido y listeners configurados.");

            // Añadir visualización básica a los mandos
            const controllerMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const controllerGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -0.5) // Línea de 50cm
            ]);

            const line1 = new THREE.Line(controllerGeometry, controllerMaterial);
            controller1.add(line1);
            console.log("Visualización añadida al mando 1.");

            const line2 = new THREE.Line(controllerGeometry.clone(), controllerMaterial.clone());
            controller2.add(line2);
            console.log("Visualización añadida al mando 2.");
        }


        // --- Manejadores de Eventos de Selección ---
        function onSelectStart(event) {
            const controller = event.target;
            const controllerIndex = (controller === controller1) ? 0 : 1;
            console.log(`Evento: selectstart detectado en mando ${controllerIndex}`);

            // Solo permitir agarrar si no hay nada agarrado ya
            if (grabbingController) {
                 console.log("DEBUG: Ya hay un objeto agarrado por el mando", (grabbingController === controller1) ? 0 : 1);
                 return;
            }
            // Solo permitir agarrar si el modelo está cargado
            if (!loadedModel) {
                console.log("DEBUG: Modelo no cargado aún.");
                return;
            }

            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            // Buscar intersección con el modelo FBX (recursivo)
            const intersects = raycaster.intersectObject(loadedModel, true);
            console.log("DEBUG: Intersecciones encontradas:", intersects.length);

            if (intersects.length > 0) {
                console.log("DEBUG: ¡Intersección con el modelo FBX!");
                // Agarrar el modelo completo (el grupo principal)
                grabbedObject = loadedModel;
                controller.attach(grabbedObject); // Adjuntar al mando activo
                grabbingController = controller; // Marcar qué mando está agarrando
                console.log(`DEBUG: Modelo FBX agarrado por mando ${controllerIndex}`);

                // Ocultar BoxHelper mientras se agarra
                if (modelBoxHelper) modelBoxHelper.visible = false;

            } else {
                 console.log("DEBUG: No se encontró intersección con el modelo FBX.");
            }
        }

        function onSelectEnd(event) {
            const controller = event.target;
            const controllerIndex = (controller === controller1) ? 0 : 1;
            console.log(`Evento: selectend detectado en mando ${controllerIndex}`);

            // Solo soltar si este mando estaba agarrando algo
            if (grabbingController === controller && grabbedObject) {
                console.log(`DEBUG: Soltando el modelo FBX desde el mando ${controllerIndex}`);
                scene.attach(grabbedObject); // Readjuntar a la escena (mantiene pos/rot global)
                grabbedObject = null;
                grabbingController = null; // Liberar el estado de agarre

                // Volver a mostrar BoxHelper
                if (modelBoxHelper) modelBoxHelper.visible = true;

            } else {
                 console.log(`DEBUG: selectend pero no había nada agarrado por este mando (${controllerIndex}).`);
            }
        }

        // --- Redimensionar Ventana ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Bucle de Animación/Renderizado ---
        function animate() {
            // Actualizar BoxHelper si existe y es visible
            if (modelBoxHelper && modelBoxHelper.visible) {
                modelBoxHelper.update();
            }

            // No necesitamos actualizar mandos explícitamente aquí
            // Tampoco rotar el modelo

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>


