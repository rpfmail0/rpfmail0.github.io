<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js + Cannon.js Billar 3 Bandas (Rango Impulso 0-1.5)</title> <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; }
        canvas { display: block; } 
        #info { 
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            color: white;
            font-size: 0.9em; 
            padding: 0 10px; 
            box-sizing: border-box;
            pointer-events: none; 
        }
         #effectInfo {
             margin-top: 5px;
             font-weight: bold;
             color: #ffcc00; 
         }
        /* Sliders visibles de nuevo */
        #controlsContainer {
           /* display: none; */ /* Hacer visible */
           position: absolute;
           top: 10px;       
           right: 10px;      
           background-color: rgba(0, 0, 0, 0.7); 
           padding: 10px 15px;
           border-radius: 8px;
           color: white;
           z-index: 101; 
           font-size: 0.9em;
           width: 200px; 
        }
        #controlsContainer > div { 
             margin-bottom: 10px; 
             text-align: center; 
        }
        /* NUEVO: Ocultar sliders específicos (2º y 3º div hijo) */
        #controlsContainer > div:nth-child(2), 
        #controlsContainer > div:nth-child(3) {
            display: none;
        }
        #controlsContainer label {
            display: block; 
            margin-bottom: 5px;
            white-space: nowrap; 
        }
        #controlsContainer .slider-value-pair {
             display: flex;
             align-items: center; 
             justify-content: center; 
        }
        #controlsContainer input[type="range"] {
            width: 120px; 
            vertical-align: middle;
            cursor: pointer;
            margin: 0 5px 0 0; 
        }
         #controlsContainer span {
            display: inline-block;
            min-width: 35px; 
            text-align: right; 
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 1px 3px;
            border-radius: 3px;
        }
        #scoreContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            z-index: 101;
            font-size: 1.2em;
        }
        #scoreContainer span {
            font-weight: bold;
            color: #00ff00; 
        }
        #splashScreen {
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #222; color: white; display: flex; 
            justify-content: center; align-items: center; font-size: 1.5em;
            z-index: 200; text-align: center; line-height: 1.5;
        }
        #effectButtonsContainer {
            position: absolute;
            bottom: 140px; 
            left: 10px;   
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr); 
            gap: 5px;
            width: 100px; 
            height: 100px; 
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 5px;
            z-index: 101;
        }
        #effectButtonsContainer button {
            font-size: 1.1em;
            background-color: #555;
            color: white;
            border: 1px solid #888;
            border-radius: 4px;
            cursor: pointer;
            padding: 0; 
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #effectButtonsContainer button.active {
            background-color: #a80; 
            border-color: #fff;
            box-shadow: 0 0 5px #ffc;
        }
        #btnCenter { grid-column: 2; grid-row: 2; }
        #btnTop    { grid-column: 2; grid-row: 1; }
        #btnBottom { grid-column: 2; grid-row: 3; }
        #btnLeft   { grid-column: 1; grid-row: 2; }
        #btnRight  { grid-column: 3; grid-row: 2; }
        
        #actionButtonsContainer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 101;
        }
        #actionButtonsContainer button {
            padding: 10px 20px;
            font-size: 1.1em;
            font-family: monospace;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #444;
            color: white;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
         #actionButtonsContainer button:hover {
             background-color: #666;
         }
         #actionButtonsContainer button:active {
             box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5);
         }
         #shootButton.hidden {
             display: none;
         }

    </style>
</head>
<body>
    <div id="splashScreen">
        Diseñado por RPF<br>Realizado por Gemini 2.5 Pro
    </div>

    <div id="scoreContainer">Carambolas: <span id="scoreValue">0</span></div>
    <div id="info">
        Flechas: Girar Vista | Rueda: Zoom | Clic Drch: Pan <br> 
        Usa los botones inferiores para Apuntar y Disparar
        <div id="effectInfo">Efecto: Centro</div> 
    </div>
    <div id="controlsContainer">
        <div>
            <label for="maxForceSlider">Impulso Disparo:</label>
            <div class="slider-value-pair">
                 
                 <input type="range" id="maxForceSlider" min="0" max="1.5" value="0.5" step="0.05"> 
                 <span id="maxForceValue">0.50</span> 
            </div>
        </div>
         <div>
            <label for="restitutionSlider">Rebote Bola-Bola (0-1):</label>
             <div class="slider-value-pair">
                 <input type="range" id="restitutionSlider" min="0" max="3" value="2" step="0.1"> 
                 <span id="restitutionValue">0.67</span> 
             </div>
        </div>
         <div>
            <label for="frictionSlider">Fricción Tapete (0.01-0.21):</label>
             <div class="slider-value-pair">
                 <input type="range" id="frictionSlider" min="1" max="5" value="1.5" step="0.1">  
                 <span id="frictionValue">0.04</span> 
             </div>
        </div>
    </div>

    <div id="effectButtonsContainer">
        <button id="btnTop" title="Efecto Arriba (Correr)">⬆️</button>
        <button id="btnLeft" title="Efecto Izquierda">⬅️</button>
        <button id="btnCenter" title="Centro" class="active">⚪</button> 
        <button id="btnRight" title="Efecto Derecha">➡️</button>
        <button id="btnBottom" title="Efecto Abajo (Retroceso)">⬇️</button>
    </div>

    <div id="actionButtonsContainer">
        <button id="aimButton">Apuntar</button>
        <button id="shootButton" class="hidden">Disparar</button> 
    </div>


    <script>
        // --- Variables globales ---
        // ... (igual que antes) ...
        let scene, camera, renderer, controls; 
        let world; 
        const timeStep = 1 / 60; 
        const balls = []; 
        const tableParts = []; 
        let tableMesh; 
        let zoomCamera; 
        let hitPointMarker; 
        let isAimingMode = false; 
        const mouseCoords = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let aimDirection = new THREE.Vector3(0,0,-1); 
        let aimIndicator; 
        let aimDirectionLine; 
        let currentImpulseMagnitude = 0; 
        // AJUSTADO: Valor inicial coincide con slider
        let maxForce = 0.5; 
        let selectedHitOffset = new CANNON.Vec3(0, 0, 0); 
        let ballHitSynth, cushionHitSynth;
        let audioInitialized = false; 
        let lastBallHitTime = 0;
        let lastCushionHitTime = 0;
        const soundDebounce = 50; 
        let score = 0;
        let scoreDisplayElement; 
        let whiteHitYellowThisShot = false;
        let whiteHitRedThisShot = false;
        let cushionHitsThisStroke = 0; 
        let isStrokeInProgress = false; 
        const stopVelocityThreshold = 0.01; 
        let ballMaterial, cushionMaterial, tableMaterial; 
        let cm_ball_ball, cm_ball_cushion, cm_ball_table;
        let effectButtons = {}; 
        let initialBallPositions = {}; 
        let aimButton, shootButton;

        // --- Constantes (Globales) ---
        const ballRadius = 0.03075; 
        const ballMass = 0.21; 
        const tableWidth = 1.42; 
        const tableHeight = 2.84; 
        const tableThickness = 0.01; 
        const cushionHeight = 0.05; 
        const cushionWidth = 0.05; 
        const minPolarAngle = 0.1; 
        const maxPolarAngle = Math.PI / 2 - 0.05; 

        // --- Inicialización ---
        function init() {
            // ... (igual que antes, excepto la creación de la mesa) ...
             if (typeof THREE === 'undefined') { console.error("THREE no está definido!"); return; }
             if (typeof CANNON === 'undefined') { console.error("CANNON no está definido!"); return; }
             if (typeof Tone === 'undefined') { console.error("Tone no está definido!"); }
             console.log("Iniciando simulación..."); 
             scoreDisplayElement = document.getElementById('scoreValue');
             updateScoreDisplay(); 
             scene = new THREE.Scene();
             scene.background = new THREE.Color(0x333333); 
             camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
             camera.position.set(0, 2.5, tableHeight / 2 + 2.0); 
             camera.layers.set(0); 
             zoomCamera = new THREE.PerspectiveCamera(15, 1, 0.1, 10); 
             zoomCamera.layers.enableAll(); 
             scene.add(zoomCamera); 
             renderer = new THREE.WebGLRenderer({ antialias: true });
             renderer.setSize(window.innerWidth, window.innerHeight);
             renderer.shadowMap.enabled = true;
             renderer.autoClear = true; 
             document.body.appendChild(renderer.domElement);
             scene.add(new THREE.AmbientLight(0xAAAAAA));
             const spotLight = new THREE.SpotLight(0xffffff, 0.9, 0, Math.PI / 4, 1);
             spotLight.position.set(0, 3, 0); 
             spotLight.castShadow = true;
             spotLight.shadow.mapSize.width = 1024; spotLight.shadow.mapSize.height = 1024;
             scene.add(spotLight);
             if (typeof THREE.OrbitControls !== 'undefined') {
                 controls = new THREE.OrbitControls(camera, renderer.domElement);
                 controls.target.set(0, 0, 0); 
                 controls.enableDamping = true; 
                 controls.dampingFactor = 0.05; 
                 controls.screenSpacePanning = false; 
                 controls.enablePan = true; 
                 controls.minDistance = 0.5; 
                 controls.maxDistance = 10;  
                 controls.minPolarAngle = minPolarAngle; 
                 controls.maxPolarAngle = maxPolarAngle; 
                 controls.update(); 
                 console.log("OrbitControls inicializado.");
             } else {
                  console.error("THREE.OrbitControls no está definido! Asegúrate de que el script se cargó.");
             }
             world = new CANNON.World();
             world.gravity.set(0, 0, 0); 
             world.broadphase = new CANNON.SAPBroadphase(world); 
             world.allowSleep = true; 
             world.solver.iterations = 20; 
             ballMaterial = new CANNON.Material('ball');
             cushionMaterial = new CANNON.Material('cushion');
             tableMaterial = new CANNON.Material('table');
             cm_ball_ball = new CANNON.ContactMaterial(ballMaterial, ballMaterial, { friction: 0.1, restitution: 2 / 3 });
             cm_ball_cushion = new CANNON.ContactMaterial(ballMaterial, cushionMaterial, { friction: 0.15, restitution: 0.8 });
             cm_ball_table = new CANNON.ContactMaterial(ballMaterial, tableMaterial, { friction: 0.035, restitution: 0.1 });
             world.addContactMaterial(cm_ball_ball);
             world.addContactMaterial(cm_ball_cushion);
             world.addContactMaterial(cm_ball_table);
            
            // 8. Crear Mesa de Billar (Tapete como Caja Delgada con MeshStandardMaterial)
            const tableGeometry = new THREE.BoxGeometry(tableWidth, tableThickness, tableHeight); 
            const tableMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.9, metalness: 0.1 }); 
            tableMesh = new THREE.Mesh(tableGeometry, tableMeshMaterial); 
            tableMesh.name = "TableSurface"; 
            tableMesh.position.y = -tableThickness / 2; 
            tableMesh.receiveShadow = true; 
            scene.add(tableMesh);
            const tableShape = new CANNON.Box(new CANNON.Vec3(tableWidth / 2, tableThickness / 2, tableHeight / 2));
            const tableBody = new CANNON.Body({ mass: 0, material: tableMaterial }); 
            tableBody.addShape(tableShape); 
            tableBody.position.copy(tableMesh.position); 
            world.addBody(tableBody);
            tableParts.push({ mesh: tableMesh, body: tableBody, type: 'table' }); 
            
            const surfaceY = 0; 
            const cushionYPos = surfaceY + cushionHeight / 2;
            const ballYPos = surfaceY + ballRadius; 
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, metalness: 0.2 });
             const cushionGeometryLong = new THREE.BoxGeometry(tableWidth + 2 * cushionWidth, cushionHeight, cushionWidth); const cushionGeometryShort = new THREE.BoxGeometry(cushionWidth, cushionHeight, tableHeight); const cushionPositions = [ { x: 0, y: cushionYPos, z: tableHeight / 2 + cushionWidth / 2, geometry: cushionGeometryLong }, { x: 0, y: cushionYPos, z: -tableHeight / 2 - cushionWidth / 2, geometry: cushionGeometryLong }, { x: tableWidth / 2 + cushionWidth / 2, y: cushionYPos, z: 0, geometry: cushionGeometryShort }, { x: -tableWidth / 2 - cushionWidth / 2, y: cushionYPos, z: 0, geometry: cushionGeometryShort } ]; cushionPositions.forEach(posData => { const cushionMesh = new THREE.Mesh(posData.geometry, woodMaterial); cushionMesh.position.set(posData.x, posData.y, posData.z); cushionMesh.castShadow = true; cushionMesh.receiveShadow = true; scene.add(cushionMesh); const cannonVec = new CANNON.Vec3(posData.geometry.parameters.width / 2, posData.geometry.parameters.height / 2, posData.geometry.parameters.depth / 2); const cushionShape = new CANNON.Box(cannonVec); const cushionBody = new CANNON.Body({ mass: 0, material: cushionMaterial }); cushionBody.addShape(cushionShape); cushionBody.position.copy(cushionMesh.position); world.addBody(cushionBody); tableParts.push({ mesh: cushionMesh, body: cushionBody, type: 'cushion' }); }); const baseHeight = 0.15; const legHeight = 0.6; const legSize = 0.1; const baseMesh = new THREE.Mesh( new THREE.BoxGeometry(tableWidth + 2*cushionWidth + 0.1, baseHeight, tableHeight + 2*cushionWidth + 0.1), woodMaterial ); baseMesh.position.y = surfaceY - tableThickness / 2 - baseHeight / 2; baseMesh.castShadow = true; scene.add(baseMesh); const legPositions = [ {x: tableWidth/2, z: tableHeight/2}, {x: -tableWidth/2, z: tableHeight/2}, {x: tableWidth/2, z: -tableHeight/2}, {x: -tableWidth/2, z: -tableHeight/2} ]; legPositions.forEach(pos => { const legMesh = new THREE.Mesh( new THREE.BoxGeometry(legSize, legHeight, legSize), woodMaterial ); legMesh.position.set(pos.x, baseMesh.position.y - baseHeight/2 - legHeight / 2, pos.z); legMesh.castShadow = true; scene.add(legMesh); });
            const sphereGeometry = new THREE.SphereGeometry(ballRadius, 32, 32); 
            const damping = 0.15; 
            const ballBodies = []; 
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.1 }); 
            const whiteMesh = new THREE.Mesh(sphereGeometry, whiteMat); 
            whiteMesh.position.set(0, ballYPos, tableHeight * 0.25); 
            whiteMesh.castShadow = true; 
            scene.add(whiteMesh); 
            const whiteShape = new CANNON.Sphere(ballRadius); 
            const whiteBody = new CANNON.Body({ mass: ballMass, material: ballMaterial, shape: whiteShape, linearDamping: damping, angularDamping: damping }); 
            whiteBody.position.copy(whiteMesh.position); 
            world.addBody(whiteBody); 
            balls.push({ mesh: whiteMesh, body: whiteBody, name: 'white' }); 
            ballBodies.push(whiteBody); 
            initialBallPositions['white'] = { mesh: whiteMesh.position.clone(), body: whiteBody.position.clone() }; 
            const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.1, metalness: 0.1 }); const yellowMesh = new THREE.Mesh(sphereGeometry, yellowMat); yellowMesh.position.set(tableWidth * 0.2, ballYPos, -tableHeight * 0.25); yellowMesh.castShadow = true; scene.add(yellowMesh); const yellowShape = new CANNON.Sphere(ballRadius); const yellowBody = new CANNON.Body({ mass: ballMass, material: ballMaterial, shape: yellowShape, linearDamping: damping, angularDamping: damping }); yellowBody.position.copy(yellowMesh.position); world.addBody(yellowBody); balls.push({ mesh: yellowMesh, body: yellowBody, name: 'yellow' }); ballBodies.push(yellowBody); 
            initialBallPositions['yellow'] = { mesh: yellowMesh.position.clone(), body: yellowBody.position.clone() }; 
            const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.1, metalness: 0.1 }); const redMesh = new THREE.Mesh(sphereGeometry, redMat); redMesh.position.set(-tableWidth * 0.2, ballYPos, -tableHeight * 0.25); redMesh.castShadow = true; scene.add(redMesh); const redShape = new CANNON.Sphere(ballRadius); const redBody = new CANNON.Body({ mass: ballMass, material: ballMaterial, shape: redShape, linearDamping: damping, angularDamping: damping }); redBody.position.copy(redMesh.position); world.addBody(redBody); balls.push({ mesh: redMesh, body: redBody, name: 'red' }); ballBodies.push(redBody); 
            initialBallPositions['red'] = { mesh: redMesh.position.clone(), body: redBody.position.clone() }; 
            console.log("Posiciones iniciales guardadas:", initialBallPositions);
            const indicatorGeo = new THREE.BoxGeometry(0.008, 0.008, 1); 
            const indicatorMat = new THREE.MeshBasicMaterial({ color: 0xff00ff }); 
            aimIndicator = new THREE.Mesh(indicatorGeo, indicatorMat);
            aimIndicator.visible = false;
            scene.add(aimIndicator);
            const hitMarkerGeo = new THREE.SphereGeometry(ballRadius * 0.6, 16, 16); 
            const hitMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); 
            hitPointMarker = new THREE.Mesh(hitMarkerGeo, hitMarkerMat);
            hitPointMarker.layers.set(1); 
            hitPointMarker.visible = false; 
            scene.add(hitPointMarker); 
            const linePoints = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1)]; 
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            aimDirectionLine = new THREE.Line(lineGeometry, lineMaterial);
            aimDirectionLine.visible = false;
            scene.add(aimDirectionLine); 
            const diamondRadius = 0.008; 
            const diamondGeo = new THREE.SphereGeometry(diamondRadius, 8, 8); 
            const diamondMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 });
            const diamondY = cushionYPos + cushionHeight / 2 + 0.001; 
            const diamondEdgeOffsetLong = tableWidth / 2; 
            const diamondEdgeOffsetShort = tableHeight / 2;
            const longSegment = tableHeight / 6;
            for (let i = 1; i <= 5; i++) {
                const zPos = -tableHeight / 2 + i * longSegment;
                const diamond1 = new THREE.Mesh(diamondGeo, diamondMat);
                diamond1.position.set(diamondEdgeOffsetLong, diamondY, zPos);
                scene.add(diamond1);
                const diamond2 = new THREE.Mesh(diamondGeo, diamondMat);
                diamond2.position.set(-diamondEdgeOffsetLong, diamondY, zPos);
                scene.add(diamond2);
            }
            const shortSegment = tableWidth / 4;
             for (let i = 1; i <= 3; i++) {
                const xPos = -tableWidth / 2 + i * shortSegment;
                 const diamond1 = new THREE.Mesh(diamondGeo, diamondMat);
                 diamond1.position.set(xPos, diamondY, diamondEdgeOffsetShort);
                 scene.add(diamond1);
                 const diamond2 = new THREE.Mesh(diamondGeo, diamondMat);
                 diamond2.position.set(xPos, diamondY, -diamondEdgeOffsetShort);
                 scene.add(diamond2);
             }
             if (typeof Tone !== 'undefined') {
                 const noiseFilter = new Tone.Filter({type : 'bandpass', frequency : 1500, Q : 1.8}).toDestination(); 
                 ballHitSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: 0 }).connect(noiseFilter); 
                cushionHitSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 } }).toDestination();
                console.log("Sintetizadores Tone.js creados (NoiseSynth para bolas).");
             } else {
                 console.error("Tone no está definido, no se crearán sintetizadores.");
             }
             window.addEventListener('resize', onWindowResize, false);
             window.addEventListener('pointerdown', onPointerDown, { once: true }); 
             window.addEventListener('keydown', onKeyRotate, false); 
             window.addEventListener('keydown', onHitOffsetChange, false); 
             ballBodies.forEach(body => { body.addEventListener('collide', onCollision); });
             setupSliders(); 
             setupEffectButtons(); 
             setupActionButtons(); 
             updateScoreDisplay(); 
             console.log("Iniciando bucle de animación...");
             animate();
        }

        // --- Bucle de Animación --- 
        function animate() {
            requestAnimationFrame(animate);
            if (controls && controls.enabled) controls.update(); 
            world.step(timeStep); 
            
            const cueBall = balls.find(b => b.name === 'white'); 

            let allStopped = true; 
            let shouldResetStroke = false;

            balls.forEach(ball => {
                // Sincronizar visuales
                ball.mesh.position.copy(ball.body.position); 
                ball.mesh.quaternion.copy(ball.body.quaternion); 

                // Comprobar si la bola está parada
                if (ball.body.velocity.lengthSquared() > stopVelocityThreshold) {
                    allStopped = false;
                }

                // Comprobar si la bola se ha caído
                const pos = ball.body.position;
                const outY = pos.y < -0.5; 
                const margin = ballRadius * 2; 
                const outX = Math.abs(pos.x) > tableWidth / 2 + margin; 
                const outZ = Math.abs(pos.z) > tableHeight / 2 + margin; 
                if (outY || outX || outZ) { 
                    resetBall(ball); 
                    shouldResetStroke = true; 
                }
            });

            // Comprobar fin de tiro y puntuar si procede
            if (isStrokeInProgress && allStopped) {
                console.log("Stroke ended.");
                if (hitYellowAfterStrokeStart && hitRedAfterStrokeStart && cushionHitsThisStroke >= 3) {
                    score++;
                    updateScoreDisplay();
                    console.log("¡Carambola a 3 Bandas! Puntuación:", score);
                } else if (hitYellowAfterStrokeStart && hitRedAfterStrokeStart) {
                    console.log("Carambola directa (no válida para 3 bandas).");
                } else {
                     console.log("Tiro fallido.");
                }
                isStrokeInProgress = false;
                whiteHitYellowThisShot = false; 
                whiteHitRedThisShot = false; 
                hitYellowAfterStrokeStart = false;
                hitRedAfterStrokeStart = false;
                cushionHitsThisStroke = 0;
            }
            else if (shouldResetStroke) {
                 isStrokeInProgress = false;
                 whiteHitYellowThisShot = false; 
                 whiteHitRedThisShot = false;
                 hitYellowAfterStrokeStart = false;
                 hitRedAfterStrokeStart = false;
                 cushionHitsThisStroke = 0;
                 isAimingMode = false; 
                 if(aimIndicator) aimIndicator.visible = false;
                 if(aimDirectionLine) aimDirectionLine.visible = false; 
                 if(hitPointMarker) hitPointMarker.visible = false;
                 currentImpulseMagnitude = 0; 
                 if(controls) controls.enabled = true; 
                 if(aimButton) aimButton.classList.remove('hidden'); 
                 if(shootButton) shootButton.classList.add('hidden'); 
                 setupAimMoveListener(false); 
            }

            // Actualizar marcador de golpeo
            if (isAimingMode && cueBall && hitPointMarker) {
                 try { 
                     const markerPosCannon = new CANNON.Vec3(); 
                     const worldOffsetCannon = new CANNON.Vec3(); 
                     if (selectedHitOffset.lengthSquared() < 0.0001) { 
                         const forwardLocal = new CANNON.Vec3(0, 0, ballRadius * 0.7); 
                         worldOffsetCannon.copy(cueBall.body.quaternion.vmult(forwardLocal)); 
                     } else { 
                         worldOffsetCannon.copy(cueBall.body.quaternion.vmult(selectedHitOffset)); 
                         const outwardOffset = worldOffsetCannon.clone(); 
                         if (outwardOffset.lengthSquared() > 0) { 
                             outwardOffset.normalize();
                             worldOffsetCannon.vadd(outwardOffset.scale(ballRadius * 0.3), worldOffsetCannon); 
                         }
                     }
                     markerPosCannon.copy(cueBall.body.position).vadd(worldOffsetCannon, markerPosCannon); 
                     hitPointMarker.position.copy(markerPosCannon); 
                     if (!hitPointMarker.visible) { hitPointMarker.visible = true; }
                 } catch (e) {
                     console.error("Error updating hitPointMarker:", e);
                     if(hitPointMarker) hitPointMarker.visible = false; 
                 }
            } else if (hitPointMarker) {
                 if (hitPointMarker.visible) { hitPointMarker.visible = false; }
            }

            // --- Renderizado ---
            camera.layers.set(0); 
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false); 
            renderer.render(scene, camera); 
            
            if (isAimingMode) { 
                if (cueBall) { 
                    try { 
                        const currentBallRadiusLiteral = 0.03075; 
                        const zoomDistance = currentBallRadiusLiteral * 10; 
                        const zoomHeight = currentBallRadiusLiteral * 1.5;  
                        const lookAheadDistance = 1.0; 
                        const lookAtPoint = cueBall.mesh.position.clone().add(aimDirection.clone().multiplyScalar(lookAheadDistance));
                        const offset = aimDirection.clone().negate().multiplyScalar(zoomDistance).add(new THREE.Vector3(0, zoomHeight, 0)); 
                        zoomCamera.position.copy(cueBall.mesh.position).add(offset);
                        zoomCamera.lookAt(lookAtPoint); 
                        const vpWidth = Math.floor(window.innerWidth / 5);  
                        const vpHeight = Math.floor(window.innerHeight / 5); 
                        const vpX = 15; const vpY = 15; 
                        renderer.setViewport(vpX, vpY, vpWidth, vpHeight);
                        renderer.setScissor(vpX, vpY, vpWidth, vpHeight);
                        renderer.setScissorTest(true); 
                        zoomCamera.aspect = vpWidth / vpHeight; 
                        zoomCamera.updateProjectionMatrix();
                        renderer.render(scene, zoomCamera); 
                        renderer.setScissorTest(false); 
                    } catch(e) {
                         console.error("Error during zoom render pass:", e);
                         renderer.setScissorTest(false); 
                    }
                }
            }
        }

        // --- Manejador de Redimensionado --- 
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Manejadores de Eventos de Puntero (Solo para apuntar) --- 
        function getPointerIntersection(event) { mouseCoords.x = (event.clientX / window.innerWidth) * 2 - 1; mouseCoords.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouseCoords, camera); const intersects = raycaster.intersectObject(tableMesh); if (intersects.length > 0) { return intersects[0].point; } return null; } 
        
        function onPointerDown(event) {
            if (!audioInitialized && typeof Tone !== 'undefined') { 
                Tone.start().then(() => { audioInitialized = true; console.log("Audio Context Started"); }).catch(e => console.error("Error starting Tone:", e)); 
            }
        } 
        
        function onPointerMove(event) { 
            if (!isAimingMode) return; 
            if (event.pointerType === 'touch') event.preventDefault(); 

            mouseCoords.x = (event.clientX / window.innerWidth) * 2 - 1; 
            mouseCoords.y = -(event.clientY / window.innerHeight) * 2 + 1; 
            raycaster.setFromCamera(mouseCoords, camera); 
            const intersectsTable = raycaster.intersectObject(tableMesh); 
            
            if (!intersectsTable.length > 0) return; 
            const currentTablePoint = intersectsTable[0].point;

            const cueBall = balls.find(b => b.name === 'white'); 
            if (!cueBall) return; 
            const cueBallPos = cueBall.mesh.position; 

            aimDirection.copy(currentTablePoint).sub(cueBallPos).normalize(); 
            aimDirection.y = 0; 

            // Leer la fuerza del slider para actualizar la longitud visual
            const maxForceSlider = document.getElementById('maxForceSlider');
            let currentPower = maxForce; 
            if (maxForceSlider) {
                 currentPower = parseFloat(maxForceSlider.value);
            }
            
            const maxSliderValue = maxForceSlider ? parseFloat(maxForceSlider.max) : 20; 
            const maxVisualLength = 1.0; 
            const powerRatio = maxSliderValue > 0 ? currentPower / maxSliderValue : 0; 
            const visualLength = Math.max(0.01, powerRatio * maxVisualLength); 
            const indicatorOffset = aimDirection.clone().multiplyScalar(visualLength / 2); 
            
            // Actualizar indicador magenta
            aimIndicator.scale.z = visualLength; 
            aimIndicator.position.copy(cueBallPos).add(new THREE.Vector3(0, 0.01, 0)).add(indicatorOffset);
            aimIndicator.lookAt(cueBallPos.clone().add(aimDirection)); 

            // Actualizar línea blanca
            if (aimDirectionLine) {
                const lineEndPoint = cueBallPos.clone().add(aimDirection.clone().multiplyScalar(10)); 
                const positions = aimDirectionLine.geometry.attributes.position;
                positions.setXYZ(0, cueBallPos.x, cueBallPos.y + 0.001, cueBallPos.z); 
                positions.setXYZ(1, lineEndPoint.x, lineEndPoint.y + 0.001, lineEndPoint.z);
                positions.needsUpdate = true;
                aimDirectionLine.geometry.computeBoundingSphere(); 
            }
        }

        function onPointerUp(event) { 
             if (event.pointerType === 'touch') event.preventDefault(); 
        }   

        // --- Nuevas Funciones para Botones ---
        function handleAimButtonClick() {
            console.log("Aim button clicked");
            const cueBall = balls.find(b => b.name === 'white'); 
            if (!cueBall) return;
            const isQuiet = cueBall.body.velocity.lengthSquared() < stopVelocityThreshold * 10; 

            if (isQuiet && !isStrokeInProgress) {
                isAimingMode = true;
                if (controls) controls.enabled = false; 
                if (aimIndicator) aimIndicator.visible = true;
                if (aimDirectionLine) aimDirectionLine.visible = true;
                if (shootButton) shootButton.classList.remove('hidden'); 
                if (aimButton) aimButton.classList.add('hidden'); 
                setupAimMoveListener(true); 
                console.log("Aiming mode activated.");
                 if (!audioInitialized && typeof Tone !== 'undefined') { 
                     Tone.start().then(() => { audioInitialized = true; console.log("Audio Context Started on Aim"); }).catch(e => console.error("Error starting Tone:", e)); 
                 }
                 // Actualizar indicadores una vez al entrar en modo apuntar
                 // Usar coordenadas centrales de pantalla como punto inicial simulado
                 onPointerMove({clientX: window.innerWidth / 2, clientY: window.innerHeight / 2, pointerType: 'mouse'}); 
            } else {
                 console.log("Cannot aim: Balls still moving or stroke in progress.");
            }
        }

        function handleShootButtonClick() {
            console.log("Shoot button clicked");
            if (!isAimingMode) return; 

            isAimingMode = false;
            if (controls) controls.enabled = true; 
            if (aimIndicator) aimIndicator.visible = false;
            if (aimDirectionLine) aimDirectionLine.visible = false;
            if (hitPointMarker) hitPointMarker.visible = false;
            if (shootButton) shootButton.classList.add('hidden'); 
            if (aimButton) aimButton.classList.remove('hidden'); 
            setupAimMoveListener(false); 

            const cueBall = balls.find(b => b.name === 'white'); 
            
            // Leer fuerza del slider en el momento del disparo
            const maxForceSlider = document.getElementById('maxForceSlider');
            if (maxForceSlider) {
                 currentImpulseMagnitude = parseFloat(maxForceSlider.value);
                 console.log("Impulse magnitude read from slider:", currentImpulseMagnitude); 
            } else {
                 currentImpulseMagnitude = maxForce; 
                 console.log("Impulse magnitude using default maxForce:", currentImpulseMagnitude); 
            }

            if (!cueBall || currentImpulseMagnitude <= 0) { 
                 console.log("Shot cancelled (no force selected)"); 
                 currentImpulseMagnitude = 0; 
                 isStrokeInProgress = false; 
            } else { 
                 const impulse = new CANNON.Vec3( aimDirection.x * currentImpulseMagnitude, 0, aimDirection.z * currentImpulseMagnitude ); 
                 console.log("Applying impulse at offset:", selectedHitOffset); 
                 cueBall.body.wakeUp(); 
                 cueBall.body.applyImpulse(impulse, selectedHitOffset); 
                 console.log(`Shot Fired! Force: ${currentImpulseMagnitude.toFixed(2)}`); 
                 console.log("Applied Impulse Vector:", impulse.x.toFixed(2), impulse.y.toFixed(2), impulse.z.toFixed(2)); 
                 setTimeout(() => { if (cueBall.body) { console.log("Velocity immediately after impulse:", cueBall.body.velocity.x.toFixed(2), cueBall.body.velocity.y.toFixed(2), cueBall.body.velocity.z.toFixed(2)); } }, 0); 
                 // No resetear currentImpulseMagnitude aquí, se lee del slider
                 isStrokeInProgress = true; 
                 whiteHitYellowThisShot = false; 
                 whiteHitRedThisShot = false; 
                 hitYellowAfterStrokeStart = false;
                 hitRedAfterStrokeStart = false;
                 cushionHitsThisStroke = 0;         
                 console.log("Stroke started, tracking collisions..."); 
            } 
        }

        // Función para añadir/quitar listener de movimiento para apuntar
        function setupAimMoveListener(attach) {
            if (attach) {
                 console.log("Attaching aim move listener");
                 window.addEventListener('pointermove', onPointerMove, false); 
            } else {
                 console.log("Removing aim move listener");
                 window.removeEventListener('pointermove', onPointerMove, false);
            }
        }

        // --- Funciones existentes (onKeyRotate, onHitOffsetChange, onCollision, updateScoreDisplay, setHitOffset, setupEffectButtons, setupSliders, resetBall) ---
        function onKeyRotate(event) { const rotateSpeed = 0.05; const target = new THREE.Vector3(0, 0, 0); const offset = new THREE.Vector3().subVectors(camera.position, target); let theta = Math.atan2(offset.z, offset.x); let phi = Math.acos(offset.y / offset.length()); const radius = offset.length(); let needsUpdate = false; switch (event.code) { case 'ArrowLeft': theta -= rotateSpeed; needsUpdate = true; break; case 'ArrowRight': theta += rotateSpeed; needsUpdate = true; break; case 'ArrowUp': phi -= rotateSpeed; phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, phi)); needsUpdate = true; break; case 'ArrowDown': phi += rotateSpeed; phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, phi)); needsUpdate = true; break; } if (needsUpdate) { offset.x = radius * Math.sin(phi) * Math.cos(theta); offset.y = radius * Math.cos(phi); offset.z = radius * Math.sin(phi) * Math.sin(theta); camera.position.copy(target).add(offset); camera.lookAt(target); if (controls) controls.update(); console.log("Camera rotated via keyboard"); } }
        function onHitOffsetChange(event) { const offsetAmount = ballRadius * 0.9; let effectName = document.getElementById('effectInfo').textContent.split(': ')[1]; switch (event.key) { case '1': selectedHitOffset.set(0, 0, 0); effectName = "Centro"; break; case '2': selectedHitOffset.set(0, offsetAmount, 0); effectName = "Correr (Arriba)"; break; case '3': selectedHitOffset.set(0, -offsetAmount, 0); effectName = "Retroceso (Abajo)"; break; case '4': selectedHitOffset.set(-offsetAmount, 0, 0); effectName = "Efecto Izquierda"; break; case '5': selectedHitOffset.set(offsetAmount, 0, 0); effectName = "Efecto Derecha"; break; default: return; } console.log("Hit offset selected:", effectName, selectedHitOffset); const effectInfoDiv = document.getElementById('effectInfo'); if(effectInfoDiv) { effectInfoDiv.textContent = `Efecto: ${effectName}`; } }
        function onCollision(event) { 
             if (!isStrokeInProgress) return; 
             const contact = event.contact;
             const bodyA = contact.bi;
             const bodyB = contact.bj;
             const whiteBallBody = balls.find(b => b.name === 'white')?.body;
             const yellowBallBody = balls.find(b => b.name === 'yellow')?.body;
             const redBallBody = balls.find(b => b.name === 'red')?.body;
             if (!whiteBallBody || !yellowBallBody || !redBallBody) return; 
             
             if ((bodyA === whiteBallBody && bodyB.material === cushionMaterial) || (bodyB === whiteBallBody && bodyA.material === cushionMaterial)) {
                 cushionHitsThisStroke++;
                 console.log("Cushion hit! Count:", cushionHitsThisStroke);
             }
             else if (!hitYellowAfterStrokeStart && ((bodyA === whiteBallBody && bodyB === yellowBallBody) || (bodyA === yellowBallBody && bodyB === whiteBallBody))) { 
                 hitYellowAfterStrokeStart = true; console.log("White hit YELLOW (during stroke)"); 
             }
             else if (!hitRedAfterStrokeStart && ((bodyA === whiteBallBody && bodyB === redBallBody) || (bodyA === redBallBody && bodyB === whiteBallBody))) { 
                 hitRedAfterStrokeStart = true; console.log("White hit RED (during stroke)"); 
             }

            // --- Reproducción de sonido ---
            if (!ballHitSynth || !cushionHitSynth) return;
            const impactVelocity = contact.getImpactVelocityAlongNormal();
            const isBodyABall = bodyA.material === ballMaterial;
            const isBodyBBall = bodyB.material === ballMaterial;
            const isBodyACushion = bodyA.material === cushionMaterial;
            const isBodyBCushion = bodyB.material === cushionMaterial;
            const now = Tone.now() * 1000; 
            try {
                if (isBodyABall && isBodyBBall) {
                    const maxVelBall = 4; 
                    const soundVelocityBall = Math.min(1, Math.abs(impactVelocity) / maxVelBall); 
                    if (soundVelocityBall < 0.05) return; 
                    if (now - lastBallHitTime > soundDebounce) {
                        ballHitSynth.triggerAttackRelease("8n", Tone.now(), soundVelocityBall); 
                        lastBallHitTime = now; 
                    }
                } else if ((isBodyABall && isBodyBCushion) || (isBodyBBall && isBodyACushion)) {
                    const maxVelCushion = 5; 
                    const soundVelocityCushion = Math.min(1, Math.abs(impactVelocity) / maxVelCushion);
                     if (soundVelocityCushion < 0.05) return; 
                     if (now - lastCushionHitTime > soundDebounce) {
                         cushionHitSynth.triggerAttackRelease("C3", "16n", Tone.now(), soundVelocityCushion); 
                         lastCushionHitTime = now; 
                     }
                }
            } catch (e) { console.error("Error triggering Tone.js sound:", e); }
        }
        function updateScoreDisplay() { if (scoreDisplayElement) { scoreDisplayElement.textContent = score; } }
        function setHitOffset(effectType) { const offsetAmount = ballRadius * 0.9; let effectName = "Centro"; Object.values(effectButtons).forEach(button => button.classList.remove('active')); switch (effectType) { case 'center': selectedHitOffset.set(0, 0, 0); effectName = "Centro"; if(effectButtons.center) effectButtons.center.classList.add('active'); break; case 'top': selectedHitOffset.set(0, offsetAmount, 0); effectName = "Correr (Arriba)"; if(effectButtons.top) effectButtons.top.classList.add('active'); break; case 'bottom': selectedHitOffset.set(0, -offsetAmount, 0); effectName = "Retroceso (Abajo)"; if(effectButtons.bottom) effectButtons.bottom.classList.add('active'); break; case 'left': selectedHitOffset.set(-offsetAmount, 0, 0); effectName = "Efecto Izquierda"; if(effectButtons.left) effectButtons.left.classList.add('active'); break; case 'right': selectedHitOffset.set(offsetAmount, 0, 0); effectName = "Efecto Derecha"; if(effectButtons.right) effectButtons.right.classList.add('active'); break; } console.log("Hit offset selected:", effectName, selectedHitOffset); const effectInfoDiv = document.getElementById('effectInfo'); if(effectInfoDiv) { effectInfoDiv.textContent = `Efecto: ${effectName}`; } }
        function setupEffectButtons() { effectButtons.center = document.getElementById('btnCenter'); effectButtons.top = document.getElementById('btnTop'); effectButtons.bottom = document.getElementById('btnBottom'); effectButtons.left = document.getElementById('btnLeft'); effectButtons.right = document.getElementById('btnRight'); if (!effectButtons.center || !effectButtons.top || !effectButtons.bottom || !effectButtons.left || !effectButtons.right) { console.error("Error: No se encontraron TODOS los botones de efecto."); return; } effectButtons.center.addEventListener('click', () => setHitOffset('center')); effectButtons.top.addEventListener('click', () => setHitOffset('top')); effectButtons.bottom.addEventListener('click', () => setHitOffset('bottom')); effectButtons.left.addEventListener('click', () => setHitOffset('left')); effectButtons.right.addEventListener('click', () => setHitOffset('right')); setHitOffset('center'); console.log("Botones de efecto configurados."); }
        function setupSliders() { const maxForceSlider = document.getElementById('maxForceSlider'); const maxForceValueSpan = document.getElementById('maxForceValue'); const restitutionSlider = document.getElementById('restitutionSlider'); const restitutionValueSpan = document.getElementById('restitutionValue'); const frictionSlider = document.getElementById('frictionSlider'); const frictionValueSpan = document.getElementById('frictionValue'); if (!maxForceSlider || !maxForceValueSpan || !restitutionSlider || !restitutionValueSpan || !frictionSlider || !frictionValueSpan) { const controlsDiv = document.getElementById('controlsContainer'); if (controlsDiv) controlsDiv.style.display = 'none'; return; } maxForceValueSpan.textContent = parseFloat(maxForceSlider.value).toFixed(1); maxForce = parseFloat(maxForceSlider.value); const initialRestitution = parseFloat(restitutionSlider.value) / 3; restitutionValueSpan.textContent = initialRestitution.toFixed(2); if(cm_ball_ball) cm_ball_ball.restitution = initialRestitution; else console.warn("cm_ball_ball no definido al inicializar slider"); const initialFriction = 0.01 + (parseFloat(frictionSlider.value) - 1) * (0.19 / 4); frictionValueSpan.textContent = initialFriction.toFixed(2); if(cm_ball_table) cm_ball_table.friction = initialFriction; else console.warn("cm_ball_table no definido al inicializar slider"); maxForceSlider.addEventListener('input', (event) => { maxForce = parseFloat(event.target.value); maxForceValueSpan.textContent = maxForce.toFixed(1); console.log("[Slider] Max Force updated:", maxForce); }); restitutionSlider.addEventListener('input', (event) => { const sliderVal = parseFloat(event.target.value); const newValue = sliderVal / 3; restitutionValueSpan.textContent = newValue.toFixed(2); if (cm_ball_ball) { cm_ball_ball.restitution = newValue; console.log("[Slider] Ball-Ball Restitution updated:", newValue); } else { console.warn("cm_ball_ball not found to update restitution"); } }); frictionSlider.addEventListener('input', (event) => { const sliderVal = parseFloat(event.target.value); const newValue = 0.01 + (sliderVal - 1) * (0.20 / 4); frictionValueSpan.textContent = newValue.toFixed(2); if (cm_ball_table) { cm_ball_table.friction = newValue; console.log("[Slider] Ball-Table Friction updated:", newValue); } else { console.warn("cm_ball_table no definido al inicializar friction"); } }); console.log("Sliders configurados."); }
        function resetBall(ball) { if (!ball || !ball.body || !ball.mesh || !initialBallPositions[ball.name]) { console.error("Intento de resetear bola inválida:", ball); return; } console.log(`--- RESETTING ${ball.name.toUpperCase()} BALL ---`); ball.body.velocity.set(0, 0, 0); ball.body.angularVelocity.set(0, 0, 0); ball.body.sleep(); ball.body.position.copy(initialBallPositions[ball.name].body); ball.body.wakeUp(); ball.mesh.position.copy(initialBallPositions[ball.name].mesh); ball.mesh.quaternion.set(0, 0, 0, 1); if (ball.name === 'white') { isStrokeInProgress = false; whiteHitYellowThisShot = false; whiteHitRedThisShot = false; hitYellowAfterStrokeStart = false; hitRedAfterStrokeStart = false; cushionHitsThisStroke = 0; isAimingMode = false; if(aimIndicator) aimIndicator.visible = false; if(aimDirectionLine) aimDirectionLine.visible = false; if(hitPointMarker) hitPointMarker.visible = false; currentImpulseMagnitude = 0; if(controls) controls.enabled = true; if(aimButton) aimButton.classList.remove('hidden'); if(shootButton) shootButton.classList.add('hidden'); setupAimMoveListener(false); } console.log(`--- ${ball.name.toUpperCase()} BALL RESET COMPLETE ---`); }

        // --- NUEVO: Configurar botones de acción ---
        function setupActionButtons() {
            aimButton = document.getElementById('aimButton');
            shootButton = document.getElementById('shootButton');

            if (!aimButton || !shootButton) {
                console.error("Error: No se encontraron los botones de acción.");
                return;
            }

            aimButton.addEventListener('click', handleAimButtonClick);
            shootButton.addEventListener('click', handleShootButtonClick);
            console.log("Botones de acción configurados.");
        }


        // --- Iniciar todo ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Setting splash screen timeout..."); 
            setTimeout(() => {
                console.log("Splash screen timeout reached."); 
                const splash = document.getElementById('splashScreen');
                console.log("Splash element found:", splash); 
                if (splash) {
                    console.log("Hiding splash screen."); 
                    splash.style.display = 'none';
                } else {
                    console.error("Splash screen element not found!");
                }
            }, 2000); 

            try {
                init(); 
            } catch (error) { 
                console.error("Error fatal durante la inicialización:", error);
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute'; errorDiv.style.top = '50%'; errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)'; errorDiv.style.padding = '20px';
                errorDiv.style.backgroundColor = 'red'; errorDiv.style.color = 'white';
                errorDiv.style.fontFamily = 'sans-serif'; errorDiv.textContent = 'Error al cargar la simulación. Revisa la consola (F12).';
                document.body.appendChild(errorDiv);
            }
        });

    </script>
</body>
</html>
